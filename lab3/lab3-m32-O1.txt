f(double):
        sub     esp, 44                      // ⬅ ОТЛИЧИЕ: нет пролога push ebp/mov ebp,esp; кадр строится от esp
                                             // ⬅ ОТЛИЧИЕ: размер кадра 44 байта (раньше было sub esp,24)

        fld     QWORD PTR [esp+48]           // ⬅ ОТЛИЧИЕ: аргумент x берётся прямо со стека относительно esp
                                             // (x = double, лежит в стеке выше текущего esp на 48 байт)

        fst     QWORD PTR [esp+16]           // ⬅ ОТЛИЧИЕ: копируем x в локалку, НЕ снимая со стека x87 (fst = store без pop)
        fstp    QWORD PTR [esp]              // ⬅ ОТЛИЧИЕ: записываем x в [esp] и POP из x87 -> готовим аргумент для sin через стек

        call    sin                          // sin(x): ⬅ ОТЛИЧИЕ: x86 зовёт sin, ожидая аргумент в памяти/стеке; результат в st(0)
        add     esp, 8                       // ⬅ ОТЛИЧИЕ: чистим 8 байт аргумента (double) после вызова sin

        fstp    QWORD PTR [esp+16]           // сохраняем sin(x) в локалку и POP из x87

        push    DWORD PTR [esp+12]           // ⬅ ОТЛИЧИЕ: странная адресация из-за кадра на esp:
        push    DWORD PTR [esp+12]           // ⬅ ОТЛИЧИЕ: кладём 8 байт x (две половины) для exp(x) (порядок/смещение отличается от -O0)

        call    exp                          // exp(x): результат в st(0)

        fmul    QWORD PTR [esp+24]           // st(0) = exp(x) * sin(x) (sin(x) лежит в локалке по esp+24)

        add     esp, 44                      // ⬅ ОТЛИЧИЕ: вместо leave — просто восстановление esp
        ret                                  // возврат; double-результат в st(0)

Главные отличия f (x86 -O1 vs x86 -O0):

⬅ ОТЛИЧИЕ: убрали ebp как frame pointer → вся адресация через esp+....

⬅ ОТЛИЧИЕ: аргумент x берётся прямо из стека ([esp+48]), а не через [ebp+8]/[ebp+12].

⬅ ОТЛИЧИЕ: больше “x87-стековой магии”: fst/fstp используются для подготовки аргументов.

⬅ ОТЛИЧИЕ: нет явного add esp,16 после exp, как было в -O0 — компоновка стека другая.

integral(double, double, int):
        push    esi                          // ⬅ ОТЛИЧИЕ: сохраняем callee-saved регистры под переменные
        push    ebx                          // ⬅ ОТЛИЧИЕ: ebx будет i, esi будет n
        sub     esp, 52                      // ⬅ ОТЛИЧИЕ: кадр на esp, без ebp; размер 52 (раньше было sub esp,88 и через ebp)

        fld     QWORD PTR [esp+64]           // ⬅ ОТЛИЧИЕ: загружаем b (double) из стека (смещение от esp)
        fst     QWORD PTR [esp+40]           // сохраняем b в локалку, не вынимая из x87 (fst)

        mov     esi, DWORD PTR [esp+80]      // ⬅ ОТЛИЧИЕ: n берём сразу в esi (регистр), а не держим в памяти
        fsubr   QWORD PTR [esp+72]           // ⬅ ОТЛИЧИЕ: st(0) = a - b или b - a? (fsubr = reverse subtract)
                                             // смысл тот же: получить (b-a) (в зависимости от порядка операндов)
                                             // в -O0 было: fld b; fsub a

        mov     DWORD PTR [esp+8], esi       // временно кладём n в память (под fild)
        fild    DWORD PTR [esp+8]            // st(0) = (double)n
        fdivp   st(1), st                    // st(0) = (b-a)/n  => h
        fstp    QWORD PTR [esp+32]           // h -> [esp+32]

        test    esi, esi                     // ⬅ ОТЛИЧИЕ: добавлена проверка n <= 0
        jle     .L6                          // если n <= 0, идём в ветку sum=0

        mov     ebx, 0                       // ⬅ ОТЛИЧИЕ: i = 0 в регистре ebx (в -O0 i жил в памяти)
        fldz                                 // st(0)=0
        fstp    QWORD PTR [esp+8]            // sum = 0.0 (в памяти)

.L5:
        mov     DWORD PTR [esp+16], ebx      // временно сохраняем i в память для fild
        fild    DWORD PTR [esp+16]           // st(0)=i
        fld     QWORD PTR [esp+32]           // st(0)=h, st(1)=i
        fmul    st(1), st                    // ⬅ ОТЛИЧИЕ: умножение через регистры стека x87: i = i*h (в st(1))
        fld     QWORD PTR [esp+40]           // st(0)=b? (или a сохранённая; тут у тебя сохранено то, что fst’нули выше)
        fadd    st(2), st                    // ⬅ ОТЛИЧИЕ: формируем x_i на уровне стека x87 без явных fstp в память

        add     ebx, 1                       // i++

        mov     DWORD PTR [esp+16], ebx      // (i+1) в память
        fild    DWORD PTR [esp+16]           // st(0)=(i+1)
        fmulp   st(2), st                    // ⬅ ОТЛИЧИЕ: умножаем (i+1)*h прямо в стеке x87
        faddp   st(1), st                    // получаем x_{i+1}
        fstp    QWORD PTR [esp+24]           // x_{i+1} -> локалка

        sub     esp, 16                      // ⬅ ОТЛИЧИЕ: подгон стека под вызов + место под аргумент double
        fstp    QWORD PTR [esp]              // ⬅ ОТЛИЧИЕ: x_i кладём как аргумент в [esp] и pop из x87
        call    f(double)                    // f(x_i), результат в st(0)
        fstp    QWORD PTR [esp+32]           // сохраняем f(x_i) (адрес с учётом sub esp,16)
        add     esp, 8                       // ⬅ ОТЛИЧИЕ: частичная корректировка стека (компилятор по-своему разложил)

        push    DWORD PTR [esp+36]           // ⬅ ОТЛИЧИЕ: передаём x_{i+1} как 2 dword, но смещения другие из-за esp-кадра
        push    DWORD PTR [esp+36]
        call    f(double)                    // f(x_{i+1})

Суммирование и “деление на 2 через умножение”
        fadd    QWORD PTR [esp+32]           // st(0) = f(x_{i+1}) + f(x_i)

        fmul    DWORD PTR .LC2               // ⬅ ОТЛИЧИЕ: умножаем на константу (скорее всего 0.5 в формате float)
                                             // в -O0 делили через "fld 2.0; fdivp"

        fadd    QWORD PTR [esp+24]           // добавляем sum (или промежуточную сумму; тут хранится sum-часть)
        fstp    QWORD PTR [esp+24]           // сохраняем обратно sum

        add     esp, 16                      // восстановить esp после подготовки аргумента/локалок
        cmp     ebx, esi                     // i сравнить с n (оба в регистрах)
        jne     .L5                          // цикл

.L4:
        fld     QWORD PTR [esp+32]           // h
        fmul    QWORD PTR [esp+8]            // h * sum -> результат в st(0)
        add     esp, 52
        pop     ebx
        pop     esi
        ret

.L6:
        fldz                                 // 0.0
        fstp    QWORD PTR [esp+8]            // sum = 0
        jmp     .L4


Главные отличия integral (x86 -O1 vs x86 -O0):

⬅ ОТЛИЧИЕ: вообще нет ebp-кадра; всё на esp+....

⬅ ОТЛИЧИЕ: n в регистре esi, i в ebx (в -O0 они были в памяти).

⬅ ОТЛИЧИЕ: добавлен ранний выход при n <= 0 (test esi, esi; jle .L6).

⬅ ОТЛИЧИЕ: деление на 2 заменено на умножение на константу .LC2 (обычно 0.5), причём как float (fmul DWORD PTR .LC2).

main:
        lea     ecx, [esp+4]                 // как раньше: подготовка к выравниванию
        and     esp, -16                     // выравнивание стека по 16 байт

        push    DWORD PTR [ecx-4]            // восстановление верхнего слова стека
        push    ebp
        mov     ebp, esp
        push    ecx
        sub     esp, 16                      // ⬅ ОТЛИЧИЕ: меньше локальных, чем в -O0 (там было больше работы с fld/fstp)

        push    150000000                    // n
        push    1074340347                   // ⬅ ОТЛИЧИЕ: b=π кладётся на стек сразу константами (high/low)
        push    1413754136
        push    0                            // a=0.0 (low/high)
        push    0
        call    integral(double, double, int)

        fstp    st(0)                        // ⬅ ОТЛИЧИЕ: просто выбросили результат интеграла (не сохраняют в память как в -O0)
        add     esp, 32                      // очистка аргументов

        mov     eax, 0                       // return 0
        mov     ecx, DWORD PTR [ebp-4]
        leave
        lea     esp, [ecx-4]
        ret

⬅ ОТЛИЧИЕ: результат integral не сохраняют (fstp st(0) просто “поп” из FPU-стека) — значит значение нигде дальше не используется.

.LC2:
        .long   1056964608                   // ⬅ ОТЛИЧИЕ: это НЕ double 2.0 как в -O0.
                                             // Это 32-битный float-константа (для fmul DWORD PTR .LC2)
                                             // По смыслу — коэффициент для /2, т.е. обычно 0.5f

Короткий список различий для отчёта (x86 -O1 vs x86 -O0)

Убрали ebp как frame pointer → адресация через esp+смещение.

i и n хранятся в регистрах (ebx, esi).

Добавлен ранний выход при n <= 0.

/2 заменили на * константу (fmul .LC2), причём константа float, не double.

В main результат интеграла не сохраняют — просто удаляют из st(0).